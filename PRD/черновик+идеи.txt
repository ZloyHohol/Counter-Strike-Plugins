Как можно реализовать MVP‑логику в плагине SourceMod
Собираем статистику в течение раунда

В player_death считаем убийства per‑player.

В bomb_planted фиксируем planter.

В bomb_defused фиксируем defuser.

В hostage_rescued считаем спасённых заложников.

Дополнительно сохраняем время первого убийства, чтобы при равенстве выбрать «кто раньше».

В конце раунда (round_end) определяем кандидата

Если раунд выигран взрывом → planter.

Если выигран разминированием → defuser, но только если у него ≥1 убийство, иначе fallback на «больше всех убил».

Если выигран спасением заложников → игрок, спасший последнего (или больше всего).

Если выигран по фрагам/таймеру → игрок с наибольшим количеством убийств (при равенстве — кто раньше достиг этого числа).

Если ничья или время вышло без урона → MVP не назначаем.

Сохраняем MVP на следующий раунд

В глобальной переменной g_iMVP храним userid победителя.

В round_start проверяем: если есть MVP с прошлого раунда → выдаём награду.

Награда MVP

Автоматическая: добавить деньги:

sourcepawn
int money = GetEntProp(mvp, Prop_Send, "m_iAccount");
SetEntProp(mvp, Prop_Send, "m_iAccount", min(money + 1000 * botCount, 16000));
Голосование: в round_start во время mp_freezetime открыть меню для живых игроков команды: «Подтвердить MVP» → если большинство «за», начислить бонус.

Практическая схема
Сбор статистики: хуки на player_death, bomb_planted, bomb_defused, hostage_rescued.

Определение MVP: обработка в round_end.

Награда: выдаём в round_start.

Голосование: меню через SourceMod API (Menu), показываем только живым игрокам в первые секунды freeze‑time.

Важный нюанс
Официальная «звезда MVP» клиенту всё равно будет показываться по его внутренним правилам. Твой плагин не может её заменить, но может добавить параллельную систему наград (деньги, сообщения, HUD, голосование). Игроки будут видеть «две реальности»: стандартную звезду и твой бонус.

1. Сбор статистики в раунде
sourcepawn
// Глобальные переменные
int g_iKills[MAXPLAYERS+1];
float g_fFirstKillTime[MAXPLAYERS+1];
int g_iBombPlanter = -1;
int g_iBombDefuser = -1;
int g_iHostageRescuer = -1;

// player_death
public void Event_PlayerDeath(Event event, const char[] name, bool dontBroadcast) {
    int attacker = GetClientOfUserId(event.GetInt("attacker"));
    int victim   = GetClientOfUserId(event.GetInt("userid"));
    if (!IsValidClient(attacker) || attacker == victim) return;

    g_iKills[attacker]++;
    if (g_fFirstKillTime[attacker] == 0.0) {
        g_fFirstKillTime[attacker] = GetGameTime();
    }
}

// bomb_planted
public void Event_BombPlanted(Event event, const char[] name, bool dontBroadcast) {
    g_iBombPlanter = GetClientOfUserId(event.GetInt("userid"));
}

// bomb_defused
public void Event_BombDefused(Event event, const char[] name, bool dontBroadcast) {
    g_iBombDefuser = GetClientOfUserId(event.GetInt("userid"));
}

// hostage_rescued
public void Event_HostageRescued(Event event, const char[] name, bool dontBroadcast) {
    g_iHostageRescuer = GetClientOfUserId(event.GetInt("userid"));
}
2. Определение MVP в конце раунда
sourcepawn
int g_iMVP = -1;

public void Event_RoundEnd(Event event, const char[] name, bool dontBroadcast) {
    g_iMVP = -1;

    int reason = event.GetInt("reason");

    if (reason == CSRoundEnd_BombExploded && IsValidClient(g_iBombPlanter)) {
        g_iMVP = g_iBombPlanter;
    }
    else if (reason == CSRoundEnd_BombDefused && IsValidClient(g_iBombDefuser)) {
        if (g_iKills[g_iBombDefuser] > 0) {
            g_iMVP = g_iBombDefuser;
        } else {
            g_iMVP = FindTopKiller();
        }
    }
    else if (reason == CSRoundEnd_HostagesRescued && IsValidClient(g_iHostageRescuer)) {
        g_iMVP = g_iHostageRescuer;
    }
    else {
        g_iMVP = FindTopKiller();
    }
}
Функция поиска «топ‑киллера»:

sourcepawn
int FindTopKiller() {
    int best = -1;
    int maxKills = 0;
    float earliest = 999999.0;

    for (int i = 1; i <= MaxClients; i++) {
        if (!IsValidClient(i)) continue;
        if (g_iKills[i] > maxKills) {
            maxKills = g_iKills[i];
            earliest = g_fFirstKillTime[i];
            best = i;
        }
        else if (g_iKills[i] == maxKills && g_fFirstKillTime[i] < earliest) {
            earliest = g_fFirstKillTime[i];
            best = i;
        }
    }
    return best;
}
3. Награда MVP в начале следующего раунда
sourcepawn
public void Event_RoundStart(Event event, const char[] name, bool dontBroadcast) {
    if (IsValidClient(g_iMVP)) {
        int botCount = CountBotsOnTeam(GetClientTeam(g_iMVP));
        int reward = 1000 * botCount;

        int money = GetEntProp(g_iMVP, Prop_Send, "m_iAccount");
        SetEntProp(g_iMVP, Prop_Send, "m_iAccount", min(money + reward, 16000));

        CPrintToChat(g_iMVP, "{green}[MVP]{default} Вы получили бонус %d$", reward);

        // Голосование: открыть меню для живых игроков в freeze‑time
        if (GetConVarInt(FindConVar("mp_freezetime")) > 0) {
            StartMVPVote(g_iMVP);
        }
    }

    // Сброс статистики для нового раунда
    ResetStats();
}
4. Голосование MVP
sourcepawn
void StartMVPVote(int candidate) {
    Menu menu = new Menu(MVPVoteHandler);
    char name[MAX_NAME_LENGTH];
    GetClientName(candidate, name, sizeof(name));
    menu.SetTitle("Подтвердить MVP: %s", name);
    menu.AddItem("yes", "Да");
    menu.AddItem("no", "Нет");

    for (int i = 1; i <= MaxClients; i++) {
        if (IsValidClient(i) && IsPlayerAlive(i)) {
            menu.Display(i, 10);
        }
    }
}

public int MVPVoteHandler(Menu menu, MenuAction action, int client, int item) {
    if (action == MenuAction_Select) {
        char choice[8];
        menu.GetItem(item, choice, sizeof(choice));
        if (StrEqual(choice, "yes")) {
            // Дополнительный бонус MVP
            int money = GetEntProp(g_iMVP, Prop_Send, "m_iAccount");
            SetEntProp(g_iMVP, Prop_Send, "m_iAccount", min(money + 500, 16000));
        }
    }
    else if (action == MenuAction_End) {
        delete menu;
    }
    return 0;
}
5. Сброс статистики
sourcepawn
void ResetStats() {
    for (int i = 1; i <= MaxClients; i++) {
        g_iKills[i] = 0;
        g_fFirstKillTime[i] = 0.0;
    }
    g_iBombPlanter = -1;
    g_iBombDefuser = -1;
    g_iHostageRescuer = -1;
}
Итог
MVP определяется в round_end по правилам CS:S/CS:GO.

В round_start MVP получает бонус (автоматически или через голосование).

Статистика сбрасывается каждый раунд.